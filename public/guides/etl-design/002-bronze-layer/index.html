<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>2. Bronze 레이어 - 원본을 있는 그대로 쌓는다 | Junho Lee | DataNexus 구축 과정</title>
<meta name="keywords" content="etl, bronze, cdc">
<meta name="description" content="Bronze에 데이터를 넣는 방법은 두 가지다. 전체를 덮어쓰거나, 바뀐 것만 가져오거나. 어떤 방식을 고르느냐에 따라 파이프라인의 복잡도가 완전히 달라진다.">
<meta name="author" content="Junho Lee">
<link rel="canonical"
    href="https://biz-agentic-ai.github.io/guides/etl-design/002-bronze-layer/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f02cd38532ee71bc47a8f72d7689b18efbda747f2e684f90cc6f2c90f2311a6b.css" integrity="sha256-8CzThTLucbxHqPctdomxjvvadH8uaE&#43;QzG8skPIxGms="
    rel="preload stylesheet" as="style">
<link rel="icon" href="https://biz-agentic-ai.github.io/favicon.svg">
<link rel="icon" type="image/svg+xml" sizes="16x16" href="https://biz-agentic-ai.github.io/favicon.svg">
<link rel="icon" type="image/svg+xml" sizes="32x32" href="https://biz-agentic-ai.github.io/favicon.svg">
<link rel="apple-touch-icon" href="https://biz-agentic-ai.github.io/favicon.svg">
<link rel="mask-icon" href="https://biz-agentic-ai.github.io/favicon.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://biz-agentic-ai.github.io/guides/etl-design/002-bronze-layer/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }
    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }
    </style>
</noscript><meta name="author" content="Junho Lee"><meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@biz_agentic_ai">
<meta name="twitter:creator" content="@biz_agentic_ai"><meta name="googlebot" content="index, follow">
<meta name="bingbot" content="index, follow">
<meta name="slurp" content="index, follow"><meta name="language" content="ko">
<meta name="geo.region" content="KR">
<meta name="geo.placename" content="Seoul"><meta property="og:type" content="article">
<meta property="og:site_name" content="Junho Lee | DataNexus 구축 과정">
<meta property="og:locale" content="ko_KR"><script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "2. Bronze 레이어 - 원본을 있는 그대로 쌓는다",
    "description": "Bronze에 데이터를 넣는 방법은 두 가지다. 전체를 덮어쓰거나, 바뀐 것만 가져오거나. 어떤 방식을 고르느냐에 따라 파이프라인의 복잡도가 완전히 달라진다.",
    "image": "",
    "author": {
      "@type": "Person",
      "name": "Junho Lee"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Junho Lee | DataNexus 구축 과정",
      "logo": {
        "@type": "ImageObject",
        "url": "https:\/\/biz-agentic-ai.github.io\/favicon.svg"
      }
    },
    "datePublished": "2026-02-22T00:00:00Z",
    "dateModified": "2026-02-22T00:00:00Z",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/biz-agentic-ai.github.io\/guides\/etl-design\/002-bronze-layer\/"
    }
  }
  </script><style>
  :root {
    --sidebar-width: 260px;
    --sidebar-bg: #1a1a2e;
    --sidebar-text: #e0e0e0;
    --sidebar-accent: #667eea;
    --sidebar-hover: rgba(102, 126, 234, 0.15);
    --sidebar-active-bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  }

   
  html {
    font-size: 15px;
  }

   
  .first-entry {
    min-height: 240px;
  }

  .first-entry .entry-header h1 {
    font-size: 24px;
  }

  .first-entry .entry-content {
    font-size: 14px;
  }

  .home-info .entry-content {
    font-size: 14px;
  }

  .entry-header h2 {
    font-size: 20px;
  }

  .entry-content {
    font-size: 13px;
  }

   
  .post-title,
  .post-single .post-title {
    font-size: 26px;
  }

  .post-content {
    font-size: 15px;
    line-height: 1.75;
  }

  .post-content h1 {
    font-size: 24px;
  }

  .post-content h2 {
    font-size: 21px;
  }

  .post-content h3 {
    font-size: 18px;
  }

  .post-content h4 {
    font-size: 16px;
  }

  .post-meta {
    font-size: 13px;
  }

  .toc a {
    font-size: 13px;
  }

  .first-entry {
    margin-top: 0;
  }

   
  .sidebar {
    position: fixed;
    top: 0;
    left: 0;
    width: var(--sidebar-width);
    height: 100vh;
    background: var(--sidebar-bg);
    color: var(--sidebar-text);
    z-index: 100;
    overflow-y: auto;
    transition: transform 0.3s ease;
  }

  .sidebar-inner {
    display: flex;
    flex-direction: column;
    height: 100%;
    padding: 24px 0;
  }

  .sidebar-header {
    padding: 0 20px 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    margin-bottom: 8px;
  }

  .sidebar-logo {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 1.3rem;
    font-weight: 700;
    color: #fff;
    text-decoration: none;
    letter-spacing: -0.02em;
  }

  .sidebar-logo-img {
    width: 28px;
    height: 28px;
    border-radius: 6px;
    object-fit: cover;
  }

  .home-logo-img {
    width: 42px;
    height: 42px;
    border-radius: 8px;
    object-fit: cover;
    vertical-align: middle;
    margin-right: 8px;
  }

  .sidebar-logo:hover {
    opacity: 0.85;
  }

  .sidebar-subtitle {
    display: block;
    font-size: 0.75rem;
    color: rgba(255, 255, 255, 0.4);
    margin-top: 2px;
    letter-spacing: 0.02em;
  }

   
  .sidebar-section ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .sidebar-section li a {
    display: block;
    padding: 9px 20px;
    color: var(--sidebar-text);
    text-decoration: none;
    font-size: 0.88rem;
    border-left: 3px solid transparent;
    transition: all 0.2s;
  }

  .sidebar-section li a:hover {
    background: var(--sidebar-hover);
    border-left-color: var(--sidebar-accent);
    color: #fff;
  }

  .sidebar-section li a.active {
    color: var(--sidebar-accent);
    font-weight: 600;
    border-left-color: var(--sidebar-accent);
  }

   
  .sidebar-section {
    padding: 8px 0;
    border-top: 1px solid rgba(255, 255, 255, 0.08);
    margin-top: 4px;
  }

  .sidebar-section-title {
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: rgba(255, 255, 255, 0.4);
    padding: 8px 20px;
    margin: 0;
    font-weight: 600;
  }

  .sidebar-section li a {
    font-size: 0.82rem;
    padding: 7px 20px;
    line-height: 1.4;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

   
  .sidebar-stats {
    padding: 10px 20px;
    border-top: 1px solid rgba(255, 255, 255, 0.08);
    margin-top: 4px;
    display: none;
    flex-direction: column;
    gap: 6px;
  }

  .sidebar-stat-pill {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 0 2px;
    height: 28px;
  }

  .stat-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .stat-dot--pv {
    background: #667eea;
  }

  .stat-dot--uv {
    background: #f5576c;
  }

  .sidebar-stat-value {
    font-weight: 600;
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.9);
    font-variant-numeric: tabular-nums;
  }

  .sidebar-stat-label {
    font-size: 0.7rem;
    color: rgba(255, 255, 255, 0.3);
  }

   
  .sidebar-dashboard-links {
    padding: 8px 20px;
    display: none;
    flex-direction: column;
    gap: 5px;
  }

  .sidebar-dashboard-links.visible {
    display: flex;
  }

  .sidebar-stats.visible {
    display: flex;
  }

  .sidebar-dashboard-links a {
    display: inline-flex;
    align-items: center;
    gap: 5px;
    padding: 4px 10px;
    font-size: 0.7rem;
    white-space: nowrap;
    color: rgba(255, 255, 255, 0.5);
    text-decoration: none;
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 6px;
    transition: all 0.2s;
  }

  .sidebar-dashboard-links a:hover {
    color: #fff;
    background: var(--sidebar-hover);
    border-color: var(--sidebar-accent);
  }

   
  .site-wrapper {
    margin-left: var(--sidebar-width);
    min-height: 100vh;
  }

   
  .sidebar-toggle {
    display: none;
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 101;
    background: var(--sidebar-active-bg);
    color: #fff;
    border: none;
    border-radius: 50%;
    width: 48px;
    height: 48px;
    cursor: pointer;
    box-shadow: 0 4px 14px rgba(102, 126, 234, 0.4);
    align-items: center;
    justify-content: center;
    transition: transform 0.2s;
  }

  .sidebar-toggle:hover {
    transform: scale(1.08);
  }

  .sidebar-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 99;
    backdrop-filter: blur(2px);
  }

   
  @media (max-width: 860px) {
    .sidebar {
      transform: translateX(-100%);
    }

    .sidebar.open {
      transform: translateX(0);
    }

    .sidebar-toggle {
      display: flex;
    }

    .sidebar-overlay.open {
      display: block;
    }

    .site-wrapper {
      margin-left: 0;
    }
  }
</style>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q0RS9ZG67P"></script>
      <script>
        var doNotTrack = false;
        if ( true ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-Q0RS9ZG67P');
        }
      </script><meta property="og:url" content="https://biz-agentic-ai.github.io/guides/etl-design/002-bronze-layer/">
  <meta property="og:site_name" content="Junho Lee | DataNexus 구축 과정">
  <meta property="og:title" content="2. Bronze 레이어 - 원본을 있는 그대로 쌓는다">
  <meta property="og:description" content="Bronze에 데이터를 넣는 방법은 두 가지다. 전체를 덮어쓰거나, 바뀐 것만 가져오거나. 어떤 방식을 고르느냐에 따라 파이프라인의 복잡도가 완전히 달라진다.">
  <meta property="og:locale" content="ko">
  <meta property="og:type" content="article">
    <meta property="article:section" content="guides">
    <meta property="article:published_time" content="2026-02-22T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-02-22T00:00:00+00:00">
    <meta property="article:tag" content="Etl">
    <meta property="article:tag" content="Bronze">
    <meta property="article:tag" content="Cdc">
      <meta property="og:see_also" content="https://biz-agentic-ai.github.io/guides/etl-design/003-silver-layer/">
      <meta property="og:see_also" content="https://biz-agentic-ai.github.io/guides/etl-design/001-medallion-architecture/">
      <meta property="og:see_also" content="https://biz-agentic-ai.github.io/guides/etl-design/004-scd/">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2. Bronze 레이어 - 원본을 있는 그대로 쌓는다">
<meta name="twitter:description" content="Bronze에 데이터를 넣는 방법은 두 가지다. 전체를 덮어쓰거나, 바뀐 것만 가져오거나. 어떤 방식을 고르느냐에 따라 파이프라인의 복잡도가 완전히 달라진다.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "기술 가이드",
      "item": "https://biz-agentic-ai.github.io/guides/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "ETL 설계",
      "item": "https://biz-agentic-ai.github.io/guides/etl-design/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "2. Bronze 레이어 - 원본을 있는 그대로 쌓는다",
      "item": "https://biz-agentic-ai.github.io/guides/etl-design/002-bronze-layer/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "2. Bronze 레이어 - 원본을 있는 그대로 쌓는다",
  "name": "2. Bronze 레이어 - 원본을 있는 그대로 쌓는다",
  "description": "Bronze에 데이터를 넣는 방법은 두 가지다. 전체를 덮어쓰거나, 바뀐 것만 가져오거나. 어떤 방식을 고르느냐에 따라 파이프라인의 복잡도가 완전히 달라진다.",
  "keywords": [
    "etl", "bronze", "cdc"
  ],
  "articleBody": "\rGoogle Colab에서 실습하기\r원본을 건드리면 돌아갈 곳이 없다 1편에서 Bronze 레이어의 원칙을 정했다. 소스 시스템에서 가져온 데이터를 변환 없이 저장한다. 타입 캐스팅도 안 하고, 컬럼명도 안 바꾼다.\n원칙은 간단한데 실제로 지키기가 어렵다. “날짜 컬럼 타입이 문자열인데 DATE로 바꿔서 넣으면 안 되나?” 같은 유혹이 생긴다. 안 된다. Bronze에서 타입을 바꾸면 원본 복원이 불가능해진다. 소스 시스템에서 \"2026-02-30\" 같은 잘못된 날짜가 넘어왔을 때, DATE로 캐스팅하면 에러가 나거나 NULL로 바뀐다. 원본이 뭐였는지 알 수 없게 된다.\nBronze는 보험이다. Silver 변환 로직에 버그가 있어도, 소스 시스템이 갑자기 스키마를 바꿔도, Bronze에서 다시 시작할 수 있다. 이 보험을 포기하면 문제가 생길 때마다 소스 시스템에서 데이터를 다시 끌어와야 한다. 소스 시스템 담당자가 협조적이라는 보장은 없다.\nFull Load와 Incremental Load Bronze에 데이터를 넣는 방법은 크게 두 가지다.\nFull Load 는 소스 테이블 전체를 매번 가져와서 덮어쓴다. 단순하다. 소스에 있는 그대로가 Bronze에 있으니까 정합성 고민이 없다. 대신 데이터가 커지면 비용이 늘어난다. 주문 테이블이 1억 건인데 하루에 신규 주문이 1만 건이라면, 나머지 9,999만 건은 어제와 똑같은 데이터를 매번 다시 가져오는 셈이다.\nIncremental Load 는 마지막 적재 이후에 변경된 데이터만 가져온다. 효율적이다. 1만 건만 가져오면 된다. 대신 복잡하다. “마지막 적재 이후\"를 어떻게 판단할 건지, 삭제된 데이터는 어떻게 감지할 건지 정해야 한다.\n어떤 걸 쓸지는 테이블 특성에 따라 다르다.\n구분 Full Load Incremental Load 구현 난이도 낮음 높음 네트워크/비용 데이터 크기에 비례 변경분에 비례 삭제 감지 자동 (전체를 덮어쓰니까) 별도 처리 필요 적합한 대상 코드 테이블, 소규모 마스터 대용량 트랜잭션 실무에서는 섞어 쓴다. 코드 테이블이나 상품 마스터처럼 건수가 적은 테이블은 Full Load로 단순하게 가져간다. 주문, 로그, 이벤트처럼 건수가 많은 테이블은 Incremental Load로 변경분만 가져간다.\n증분의 기준을 잡는 법 Incremental Load에서 가장 중요한 건 “무엇이 변경되었는가\"를 판단하는 기준이다. 흔히 쓰는 방법이 세 가지 있다.\n타임스탬프 기반. 소스 테이블에 updated_at 같은 수정일시 컬럼이 있으면 가장 간단하다. 마지막 적재 시점 이후의 행만 가져온다. 조건이 하나 있다. 소스 시스템이 수정일시를 정직하게 갱신해야 한다. 데이터를 UPDATE하면서 updated_at을 안 바꾸는 시스템이 의외로 많다.\n자동 증가 키 기반. order_id처럼 단조 증가하는 PK가 있으면 마지막으로 가져온 ID 이후의 행만 가져온다. INSERT는 잡히지만 UPDATE는 못 잡는다. 주문번호가 한 번 발행되면 바뀌지 않는 로그성 테이블에 적합하다.\nCDC(Change Data Capture). 소스 데이터베이스의 변경 로그를 직접 읽는다. Debezium 같은 도구가 MySQL이나 PostgreSQL의 WAL(Write-Ahead Log)을 캡처해서 INSERT, UPDATE, DELETE를 전부 잡아낸다. 가장 정확하지만 인프라 구성이 필요하다.\n타임스탬프 기반: WHERE updated_at \u003e '마지막 적재 시점' 자동 증가 키: WHERE order_id \u003e 마지막_적재_ID CDC: 데이터베이스 변경 로그 캡처 DuckDB로 두 방식을 직접 비교한다 1편에서 세팅한 환경을 이어서 쓴다.\nimport duckdb conn = duckdb.connect('warehouse.duckdb') Full Load 시뮬레이션 Full Load는 간단하다. 기존 데이터를 지우고 전체를 다시 넣는다.\n# 소스 데이터가 변경된 상황을 시뮬레이션 # 실제로는 소스 시스템에서 SELECT * 로 전체를 가져온다 conn.execute(\"\"\" -- Full Load: 통째로 교체 CREATE OR REPLACE TABLE bronze.orders AS SELECT * FROM read_csv_auto( 'https://raw.githubusercontent.com/dbt-labs/jaffle_shop/main/seeds/raw_orders.csv' ); \"\"\") print(\"Full Load 완료:\", conn.execute(\"SELECT count(*) FROM bronze.orders\").fetchone()[0], \"건\") CREATE OR REPLACE TABLE이 핵심이다. 매번 테이블을 새로 만든다. 이전 데이터는 사라지고 소스의 현재 상태가 그대로 들어온다.\nIncremental Load 시뮬레이션 Incremental Load는 한 단계가 더 있다. 마지막으로 가져온 지점을 기억해야 한다.\n# 워터마크 테이블: 마지막 적재 지점을 기록 conn.execute(\"\"\" CREATE TABLE IF NOT EXISTS bronze.watermarks ( table_name VARCHAR PRIMARY KEY, last_loaded_id INTEGER, last_loaded_at TIMESTAMP DEFAULT current_timestamp ); \"\"\") # 현재 워터마크 확인 watermark = conn.execute(\"\"\" SELECT COALESCE(last_loaded_id, 0) FROM bronze.watermarks WHERE table_name = 'orders' \"\"\").fetchone() last_id = watermark[0] if watermark else 0 print(f\"마지막 적재 ID: {last_id}\") # 증분 적재: last_id 이후 데이터만 가져온다 conn.execute(f\"\"\" INSERT INTO bronze.orders SELECT * FROM read_csv_auto( 'https://raw.githubusercontent.com/dbt-labs/jaffle_shop/main/seeds/raw_orders.csv' ) WHERE id \u003e {last_id}; \"\"\") # 워터마크 갱신 conn.execute(\"\"\" INSERT OR REPLACE INTO bronze.watermarks (table_name, last_loaded_id, last_loaded_at) SELECT 'orders', MAX(id), current_timestamp FROM bronze.orders; \"\"\") print(\"Incremental Load 완료\") watermarks 테이블이 증분 적재의 핵심이다. 어디까지 가져왔는지를 기록해두고, 다음 적재 때 그 이후만 가져온다. 이 패턴을 하이 워터마크(High Watermark) 라고 부른다.\n메타데이터 컬럼을 붙인다 Bronze에 원본 데이터만 넣으면 나중에 답이 안 나오는 질문이 생긴다. “이 데이터가 언제 적재된 건가?” “어느 소스에서 온 건가?”\n원본 컬럼은 그대로 두고, 메타데이터 컬럼을 추가한다.\nconn.execute(\"\"\" CREATE OR REPLACE TABLE bronze.orders_with_meta AS SELECT *, current_timestamp AS _loaded_at, 'jaffle_shop' AS _source_system, 'full' AS _load_type FROM read_csv_auto( 'https://raw.githubusercontent.com/dbt-labs/jaffle_shop/main/seeds/raw_orders.csv' ); \"\"\") conn.execute(\"SELECT * FROM bronze.orders_with_meta LIMIT 3\").fetchdf() _loaded_at, _source_system, _load_type. 언더스코어로 시작하는 이유는 원본 컬럼과 구분하기 위해서다. 원본에 loaded_at이라는 컬럼이 있을 수도 있으니까.\n이 메타데이터가 있으면 Silver 변환에서 문제가 생겼을 때 “언제 적재한 데이터까지는 정상이고, 이후부터 이상하다\"는 식으로 범위를 좁힐 수 있다.\n적재 패턴 정리 Bronze 적재 패턴을 정리하면 이렇다.\n패턴 적용 대상 구현 Full Load (덮어쓰기) 코드 테이블, 소규모 마스터 CREATE OR REPLACE TABLE Full Load (스냅샷) 일별 현황 보관이 필요한 경우 파티션 키로 적재일 사용 Incremental (타임스탬프) updated_at이 있는 테이블 WHERE updated_at \u003e 워터마크 Incremental (자동 증가 키) 로그, 이벤트, 주문 WHERE id \u003e 워터마크 CDC 삭제 감지가 필요한 경우 Debezium + Kafka Full Load 중에 스냅샷 방식이 하나 더 있다. 덮어쓰기가 아니라 적재일 기준으로 매일의 전체 상태를 따로 저장하는 방식이다. 상품 마스터의 어제 상태와 오늘 상태를 비교하고 싶을 때 쓴다. 스토리지를 많이 먹지만, 1편에서 얘기했듯 클라우드 환경에서 스토리지 비용은 무시할 수 있는 수준이다.\n실무 참고: Airflow로 Bronze 적재 Bronze 적재를 Airflow DAG으로 짜면 테이블마다 Full Load / Incremental Load를 구분해서 태스크를 나눌 수 있다.\nfrom airflow import DAG from airflow.operators.python import PythonOperator from datetime import datetime import duckdb def load_full(table_name, source_url, **context): \"\"\"Full Load: 전체 교체\"\"\" conn = duckdb.connect('warehouse.duckdb') conn.execute(f\"\"\" CREATE OR REPLACE TABLE bronze.{table_name} AS SELECT *, current_timestamp AS _loaded_at, '{table_name}' AS _source_system, 'full' AS _load_type FROM read_csv_auto('{source_url}') \"\"\") conn.close() def load_incremental(table_name, source_url, key_column, **context): \"\"\"Incremental Load: 워터마크 이후만\"\"\" conn = duckdb.connect('warehouse.duckdb') wm = conn.execute(f\"\"\" SELECT COALESCE(last_loaded_id, 0) FROM bronze.watermarks WHERE table_name = '{table_name}' \"\"\").fetchone() last_id = wm[0] if wm else 0 conn.execute(f\"\"\" INSERT INTO bronze.{table_name} SELECT *, current_timestamp AS _loaded_at FROM read_csv_auto('{source_url}') WHERE {key_column} \u003e {last_id} \"\"\") conn.close() with DAG( dag_id='bronze_ingestion', schedule='0 5 * * *', start_date=datetime(2026, 1, 1), catchup=False, ) as dag: # 소규모 마스터 → Full Load load_customers = PythonOperator( task_id='load_customers_full', python_callable=load_full, op_kwargs={'table_name': 'customers', 'source_url': '...'}, ) # 대용량 트랜잭션 → Incremental Load load_orders = PythonOperator( task_id='load_orders_incremental', python_callable=load_incremental, op_kwargs={ 'table_name': 'orders', 'source_url': '...', 'key_column': 'id', }, ) # 병렬 실행 — 테이블 간 의존 관계가 없으니까 [load_customers, load_orders] 소규모 마스터는 load_full, 대용량 트랜잭션은 load_incremental. 테이블 특성에 맞게 함수를 나눠서 호출한다. 테이블 간에는 의존 관계가 없으니 Airflow가 병렬로 실행한다.\n다음 글에서는 Silver 레이어를 다룬다. Bronze에 쌓아둔 원본 데이터를 정제하고 표준화하는 과정이다. dbt를 본격적으로 쓰기 시작한다.\nGoogle Colab에서 실습하기\r",
  "wordCount" : "1015",
  "inLanguage": "en",
  "datePublished": "2026-02-22T00:00:00Z",
  "dateModified": "2026-02-22T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Junho Lee"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://biz-agentic-ai.github.io/guides/etl-design/002-bronze-layer/"
  },
  "publisher": {
    "@type": "Person",
    "name": "Junho Lee | DataNexus 구축 과정",
    "logo": {
      "@type": "ImageObject",
      "url": "https://biz-agentic-ai.github.io/favicon.svg"
    }
  }
}
</script>
</head>

<body class="" id="top"><script data-goatcounter="https://biz-agentic-ai.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
<aside class="sidebar" id="sidebar">
  <div class="sidebar-inner"><div class="sidebar-header">
      <a href="https://biz-agentic-ai.github.io/" class="sidebar-logo">
        <img src="/images/DataNexus_Logo.jpg" alt="DataNexus" class="sidebar-logo-img">
        DataNexus
      </a>
      <span class="sidebar-subtitle">구축 과정</span>
    </div>
    <div class="sidebar-section">
      <h3 class="sidebar-section-title">DataNexus Series</h3>
      <ul>
        <li>
          <a href="https://biz-agentic-ai.github.io/posts/datanexus/004-skos-compatibility-layer/" title="4. SKOS 호환 레이어를 왜 넣었는가" >
            4. SKOS 호환 레이어를 왜 넣었는가
          </a>
        </li>
        <li>
          <a href="https://biz-agentic-ai.github.io/posts/datanexus/003-datahub-glossary-as-ontology/" title="3. DataHub Glossary를 온톨로지로 쓸 수 있을까" >
            3. DataHub Glossary를 온톨로지로 쓸 수 있을까
          </a>
        </li>
        <li>
          <a href="https://biz-agentic-ai.github.io/posts/datanexus/002-architecture-decisions/" title="2. 4개의 오픈소스를 이 조합으로 결정하기까지" >
            2. 4개의 오픈소스를 이 조합으로 결정하기까지
          </a>
        </li>
        <li>
          <a href="https://biz-agentic-ai.github.io/posts/datanexus/001-why-datanexus/" title="1. 왜 DataNexus를 만드는가" >
            1. 왜 DataNexus를 만드는가
          </a>
        </li>
      </ul>
    </div><div class="sidebar-stats" id="sidebar-stats">
      <div class="sidebar-stat-pill" id="gc-container-pv" style="display:none;">
        <span class="stat-dot stat-dot--pv"></span>
        <span class="sidebar-stat-value" id="gc-value-pv">-</span>
        <span class="sidebar-stat-label">views</span>
      </div>
      <div class="sidebar-stat-pill" id="gc-container-uv" style="display:none;">
        <span class="stat-dot stat-dot--uv"></span>
        <span class="sidebar-stat-value" id="gc-value-uv">-</span>
        <span class="sidebar-stat-label">visitors</span>
      </div>
    </div>
    <script>
      (function () {
        var p = encodeURIComponent(location.pathname);
        fetch('https://biz-agentic-ai.goatcounter.com/counter/' + p + '.json')
          .then(function (r) { return r.json(); })
          .then(function (d) {
            if (d.count) {
              document.getElementById('gc-value-pv').textContent = d.count;
              document.getElementById('gc-container-pv').style.display = '';
            }
            if (d.count_unique) {
              document.getElementById('gc-value-uv').textContent = d.count_unique;
              document.getElementById('gc-container-uv').style.display = '';
            }
          })
          .catch(function () { });
      })();
    </script><div class="sidebar-dashboard-links" id="dashboard-links">
      <a href="https://biz-agentic-ai.goatcounter.com/" target="_blank" rel="noopener">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="20" x2="18" y2="10"></line>
          <line x1="12" y1="20" x2="12" y2="4"></line>
          <line x1="6" y1="20" x2="6" y2="14"></line>
        </svg>
        GoatCounter
      </a>
      <a href="https://analytics.google.com/analytics/web/" target="_blank" rel="noopener">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path>
          <path d="M22 12A10 10 0 0 0 12 2v10z"></path>
        </svg>
        GA4 Dashboard
      </a>
    </div>
    <script>
      (function () {
        var el = document.getElementById('dashboard-links');
        var stats = document.getElementById('sidebar-stats');
        if (localStorage.getItem('dn-admin')) {
          el.classList.add('visible');
          stats.classList.add('visible');
        }
        document.querySelector('.sidebar-logo').addEventListener('dblclick', function () {
          var on = localStorage.getItem('dn-admin');
          if (on) {
            localStorage.removeItem('dn-admin');
            el.classList.remove('visible');
            stats.classList.remove('visible');
          } else {
            localStorage.setItem('dn-admin', '1');
            el.classList.add('visible');
            stats.classList.add('visible');
          }
        });
      })();
    </script>

  </div>
</aside><button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
  <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor"
    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <line x1="3" y1="12" x2="21" y2="12"></line>
    <line x1="3" y1="6" x2="21" y2="6"></line>
    <line x1="3" y1="18" x2="21" y2="18"></line>
  </svg>
</button>
<div class="sidebar-overlay" id="sidebar-overlay"></div><div class="site-wrapper">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://biz-agentic-ai.github.io/" accesskey="h" title="Junho Lee | DataNexus 구축 과정 (Alt + H)">Junho Lee | DataNexus 구축 과정</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://biz-agentic-ai.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://biz-agentic-ai.github.io/guides/" title="Guides">
                    <span>Guides</span>
                </a>
            </li>
            <li>
                <a href="https://biz-agentic-ai.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://biz-agentic-ai.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://biz-agentic-ai.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://biz-agentic-ai.github.io/">홈</a>&nbsp;»&nbsp;<a href="https://biz-agentic-ai.github.io/guides/">기술 가이드</a>&nbsp;»&nbsp;<a href="https://biz-agentic-ai.github.io/guides/etl-design/">ETL 설계</a></div>
    <h1 class="post-title entry-hint-parent">
      2. Bronze 레이어 - 원본을 있는 그대로 쌓는다
    </h1>
    <div class="post-meta"><span title='2026-02-22 00:00:00 +0000 UTC'>February 22, 2026</span>&nbsp;·&nbsp;5 분&nbsp;·&nbsp;Junho Lee

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">목차</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%ec%9b%90%eb%b3%b8%ec%9d%84-%ea%b1%b4%eb%93%9c%eb%a6%ac%eb%a9%b4-%eb%8f%8c%ec%95%84%ea%b0%88-%ea%b3%b3%ec%9d%b4-%ec%97%86%eb%8b%a4" aria-label="원본을 건드리면 돌아갈 곳이 없다">원본을 건드리면 돌아갈 곳이 없다</a></li>
                <li>
                    <a href="#full-load%ec%99%80-incremental-load" aria-label="Full Load와 Incremental Load">Full Load와 Incremental Load</a></li>
                <li>
                    <a href="#%ec%a6%9d%eb%b6%84%ec%9d%98-%ea%b8%b0%ec%a4%80%ec%9d%84-%ec%9e%a1%eb%8a%94-%eb%b2%95" aria-label="증분의 기준을 잡는 법">증분의 기준을 잡는 법</a></li>
                <li>
                    <a href="#duckdb%eb%a1%9c-%eb%91%90-%eb%b0%a9%ec%8b%9d%ec%9d%84-%ec%a7%81%ec%a0%91-%eb%b9%84%ea%b5%90%ed%95%9c%eb%8b%a4" aria-label="DuckDB로 두 방식을 직접 비교한다">DuckDB로 두 방식을 직접 비교한다</a><ul>
                        
                <li>
                    <a href="#full-load-%ec%8b%9c%eb%ae%ac%eb%a0%88%ec%9d%b4%ec%85%98" aria-label="Full Load 시뮬레이션">Full Load 시뮬레이션</a></li>
                <li>
                    <a href="#incremental-load-%ec%8b%9c%eb%ae%ac%eb%a0%88%ec%9d%b4%ec%85%98" aria-label="Incremental Load 시뮬레이션">Incremental Load 시뮬레이션</a></li></ul>
                </li>
                <li>
                    <a href="#%eb%a9%94%ed%83%80%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%bb%ac%eb%9f%bc%ec%9d%84-%eb%b6%99%ec%9d%b8%eb%8b%a4" aria-label="메타데이터 컬럼을 붙인다">메타데이터 컬럼을 붙인다</a></li>
                <li>
                    <a href="#%ec%a0%81%ec%9e%ac-%ed%8c%a8%ed%84%b4-%ec%a0%95%eb%a6%ac" aria-label="적재 패턴 정리">적재 패턴 정리</a></li>
                <li>
                    <a href="#%ec%8b%a4%eb%ac%b4-%ec%b0%b8%ea%b3%a0-airflow%eb%a1%9c-bronze-%ec%a0%81%ec%9e%ac" aria-label="실무 참고: Airflow로 Bronze 적재">실무 참고: Airflow로 Bronze 적재</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><div style="margin: 1.2em 0;">
  <a href="https://colab.research.google.com/github/biz-agentic-ai/biz-agentic-ai.github.io/blob/main/notebooks/etl-002-bronze-layer.ipynb" target="_blank" rel="noopener noreferrer"
     style="display: inline-flex; align-items: center; gap: 8px; padding: 10px 20px;
            background: linear-gradient(135deg, #f9ab00 0%, #f57c00 100%);
            color: #fff; text-decoration: none; border-radius: 8px;
            font-weight: 600; font-size: 0.95em;
            box-shadow: 0 2px 8px rgba(245,124,0,0.25);
            transition: all 0.2s ease;">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" fill="white"/>
    </svg>
    Google Colab에서 실습하기
  </a>
</div>

<h2 id="원본을-건드리면-돌아갈-곳이-없다">원본을 건드리면 돌아갈 곳이 없다<a hidden class="anchor" aria-hidden="true" href="#원본을-건드리면-돌아갈-곳이-없다">#</a></h2>
<p><a href="https://biz-agentic-ai.github.io/guides/etl-design/001-medallion-architecture/">1편</a>에서 Bronze 레이어의 원칙을 정했다. 소스 시스템에서 가져온 데이터를 변환 없이 저장한다. 타입 캐스팅도 안 하고, 컬럼명도 안 바꾼다.</p>
<p>원칙은 간단한데 실제로 지키기가 어렵다. &ldquo;날짜 컬럼 타입이 문자열인데 DATE로 바꿔서 넣으면 안 되나?&rdquo; 같은 유혹이 생긴다. 안 된다. Bronze에서 타입을 바꾸면 원본 복원이 불가능해진다. 소스 시스템에서 <code>&quot;2026-02-30&quot;</code> 같은 잘못된 날짜가 넘어왔을 때, DATE로 캐스팅하면 에러가 나거나 NULL로 바뀐다. 원본이 뭐였는지 알 수 없게 된다.</p>
<p>Bronze는 보험이다. Silver 변환 로직에 버그가 있어도, 소스 시스템이 갑자기 스키마를 바꿔도, Bronze에서 다시 시작할 수 있다. 이 보험을 포기하면 문제가 생길 때마다 소스 시스템에서 데이터를 다시 끌어와야 한다. 소스 시스템 담당자가 협조적이라는 보장은 없다.</p>
<h2 id="full-load와-incremental-load">Full Load와 Incremental Load<a hidden class="anchor" aria-hidden="true" href="#full-load와-incremental-load">#</a></h2>
<p>Bronze에 데이터를 넣는 방법은 크게 두 가지다.</p>
<p><strong>Full Load</strong> 는 소스 테이블 전체를 매번 가져와서 덮어쓴다. 단순하다. 소스에 있는 그대로가 Bronze에 있으니까 정합성 고민이 없다. 대신 데이터가 커지면 비용이 늘어난다. 주문 테이블이 1억 건인데 하루에 신규 주문이 1만 건이라면, 나머지 9,999만 건은 어제와 똑같은 데이터를 매번 다시 가져오는 셈이다.</p>
<p><strong>Incremental Load</strong> 는 마지막 적재 이후에 변경된 데이터만 가져온다. 효율적이다. 1만 건만 가져오면 된다. 대신 복잡하다. &ldquo;마지막 적재 이후&quot;를 어떻게 판단할 건지, 삭제된 데이터는 어떻게 감지할 건지 정해야 한다.</p>
<p>어떤 걸 쓸지는 테이블 특성에 따라 다르다.</p>
<table>
  <thead>
      <tr>
          <th>구분</th>
          <th>Full Load</th>
          <th>Incremental Load</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>구현 난이도</td>
          <td>낮음</td>
          <td>높음</td>
      </tr>
      <tr>
          <td>네트워크/비용</td>
          <td>데이터 크기에 비례</td>
          <td>변경분에 비례</td>
      </tr>
      <tr>
          <td>삭제 감지</td>
          <td>자동 (전체를 덮어쓰니까)</td>
          <td>별도 처리 필요</td>
      </tr>
      <tr>
          <td>적합한 대상</td>
          <td>코드 테이블, 소규모 마스터</td>
          <td>대용량 트랜잭션</td>
      </tr>
  </tbody>
</table>
<p>실무에서는 섞어 쓴다. 코드 테이블이나 상품 마스터처럼 건수가 적은 테이블은 Full Load로 단순하게 가져간다. 주문, 로그, 이벤트처럼 건수가 많은 테이블은 Incremental Load로 변경분만 가져간다.</p>
<h2 id="증분의-기준을-잡는-법">증분의 기준을 잡는 법<a hidden class="anchor" aria-hidden="true" href="#증분의-기준을-잡는-법">#</a></h2>
<p>Incremental Load에서 가장 중요한 건 &ldquo;무엇이 변경되었는가&quot;를 판단하는 기준이다. 흔히 쓰는 방법이 세 가지 있다.</p>
<p><strong>타임스탬프 기반.</strong> 소스 테이블에 <code>updated_at</code> 같은 수정일시 컬럼이 있으면 가장 간단하다. 마지막 적재 시점 이후의 행만 가져온다. 조건이 하나 있다. 소스 시스템이 수정일시를 정직하게 갱신해야 한다. 데이터를 UPDATE하면서 <code>updated_at</code>을 안 바꾸는 시스템이 의외로 많다.</p>
<p><strong>자동 증가 키 기반.</strong> <code>order_id</code>처럼 단조 증가하는 PK가 있으면 마지막으로 가져온 ID 이후의 행만 가져온다. INSERT는 잡히지만 UPDATE는 못 잡는다. 주문번호가 한 번 발행되면 바뀌지 않는 로그성 테이블에 적합하다.</p>
<p><strong>CDC(Change Data Capture).</strong> 소스 데이터베이스의 변경 로그를 직접 읽는다. Debezium 같은 도구가 MySQL이나 PostgreSQL의 WAL(Write-Ahead Log)을 캡처해서 INSERT, UPDATE, DELETE를 전부 잡아낸다. 가장 정확하지만 인프라 구성이 필요하다.</p>
<div class="highlight"><pre tabindex="0" style="color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>타임스탬프 기반:  WHERE updated_at &gt; &#39;마지막 적재 시점&#39;
</span></span><span style="display:flex;"><span>자동 증가 키:    WHERE order_id &gt; 마지막_적재_ID
</span></span><span style="display:flex;"><span>CDC:            데이터베이스 변경 로그 캡처
</span></span></code></pre></div><h2 id="duckdb로-두-방식을-직접-비교한다">DuckDB로 두 방식을 직접 비교한다<a hidden class="anchor" aria-hidden="true" href="#duckdb로-두-방식을-직접-비교한다">#</a></h2>
<p><a href="https://biz-agentic-ai.github.io/guides/etl-design/001-medallion-architecture/">1편</a>에서 세팅한 환경을 이어서 쓴다.</p>
<div class="highlight"><pre tabindex="0" style="color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#7dcfff">import</span> <span style="color:#e0af68">duckdb</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>conn <span style="color:#9ece6a;font-weight:bold">=</span> duckdb<span style="color:#9ece6a;font-weight:bold">.</span>connect(<span style="color:#9ece6a">&#39;warehouse.duckdb&#39;</span>)
</span></span></code></pre></div><h3 id="full-load-시뮬레이션">Full Load 시뮬레이션<a hidden class="anchor" aria-hidden="true" href="#full-load-시뮬레이션">#</a></h3>
<p>Full Load는 간단하다. 기존 데이터를 지우고 전체를 다시 넣는다.</p>
<div class="highlight"><pre tabindex="0" style="color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#414868;font-style:italic"># 소스 데이터가 변경된 상황을 시뮬레이션</span>
</span></span><span style="display:flex;"><span><span style="color:#414868;font-style:italic"># 실제로는 소스 시스템에서 SELECT * 로 전체를 가져온다</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>conn<span style="color:#9ece6a;font-weight:bold">.</span>execute(<span style="color:#9ece6a">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">-- Full Load: 통째로 교체
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">CREATE OR REPLACE TABLE bronze.orders AS
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">SELECT *
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">FROM read_csv_auto(
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">  &#39;https://raw.githubusercontent.com/dbt-labs/jaffle_shop/main/seeds/raw_orders.csv&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">);
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">&#34;&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#9ece6a">print</span>(<span style="color:#9ece6a">&#34;Full Load 완료:&#34;</span>,
</span></span><span style="display:flex;"><span>      conn<span style="color:#9ece6a;font-weight:bold">.</span>execute(<span style="color:#9ece6a">&#34;SELECT count(*) FROM bronze.orders&#34;</span>)<span style="color:#9ece6a;font-weight:bold">.</span>fetchone()[<span style="color:#e0af68">0</span>], <span style="color:#9ece6a">&#34;건&#34;</span>)
</span></span></code></pre></div><p><code>CREATE OR REPLACE TABLE</code>이 핵심이다. 매번 테이블을 새로 만든다. 이전 데이터는 사라지고 소스의 현재 상태가 그대로 들어온다.</p>
<h3 id="incremental-load-시뮬레이션">Incremental Load 시뮬레이션<a hidden class="anchor" aria-hidden="true" href="#incremental-load-시뮬레이션">#</a></h3>
<p>Incremental Load는 한 단계가 더 있다. 마지막으로 가져온 지점을 기억해야 한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#414868;font-style:italic"># 워터마크 테이블: 마지막 적재 지점을 기록</span>
</span></span><span style="display:flex;"><span>conn<span style="color:#9ece6a;font-weight:bold">.</span>execute(<span style="color:#9ece6a">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">CREATE TABLE IF NOT EXISTS bronze.watermarks (
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">    table_name VARCHAR PRIMARY KEY,
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">    last_loaded_id INTEGER,
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">    last_loaded_at TIMESTAMP DEFAULT current_timestamp
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">);
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">&#34;&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#414868;font-style:italic"># 현재 워터마크 확인</span>
</span></span><span style="display:flex;"><span>watermark <span style="color:#9ece6a;font-weight:bold">=</span> conn<span style="color:#9ece6a;font-weight:bold">.</span>execute(<span style="color:#9ece6a">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">SELECT COALESCE(last_loaded_id, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">FROM bronze.watermarks
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">WHERE table_name = &#39;orders&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">&#34;&#34;&#34;</span>)<span style="color:#9ece6a;font-weight:bold">.</span>fetchone()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>last_id <span style="color:#9ece6a;font-weight:bold">=</span> watermark[<span style="color:#e0af68">0</span>] <span style="color:#bb9af7">if</span> watermark <span style="color:#bb9af7">else</span> <span style="color:#e0af68">0</span>
</span></span><span style="display:flex;"><span><span style="color:#9ece6a">print</span>(<span style="color:#9d7cd8">f</span><span style="color:#9ece6a">&#34;마지막 적재 ID: </span><span style="color:#9ece6a">{</span>last_id<span style="color:#9ece6a">}</span><span style="color:#9ece6a">&#34;</span>)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#414868;font-style:italic"># 증분 적재: last_id 이후 데이터만 가져온다</span>
</span></span><span style="display:flex;"><span>conn<span style="color:#9ece6a;font-weight:bold">.</span>execute(<span style="color:#9d7cd8">f</span><span style="color:#9ece6a">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">INSERT INTO bronze.orders
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">SELECT *
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">FROM read_csv_auto(
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">  &#39;https://raw.githubusercontent.com/dbt-labs/jaffle_shop/main/seeds/raw_orders.csv&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">)
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">WHERE id &gt; </span><span style="color:#9ece6a">{</span>last_id<span style="color:#9ece6a">}</span><span style="color:#9ece6a">;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">&#34;&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#414868;font-style:italic"># 워터마크 갱신</span>
</span></span><span style="display:flex;"><span>conn<span style="color:#9ece6a;font-weight:bold">.</span>execute(<span style="color:#9ece6a">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">INSERT OR REPLACE INTO bronze.watermarks (table_name, last_loaded_id, last_loaded_at)
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">SELECT &#39;orders&#39;, MAX(id), current_timestamp
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">FROM bronze.orders;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">&#34;&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#9ece6a">print</span>(<span style="color:#9ece6a">&#34;Incremental Load 완료&#34;</span>)
</span></span></code></pre></div><p><code>watermarks</code> 테이블이 증분 적재의 핵심이다. 어디까지 가져왔는지를 기록해두고, 다음 적재 때 그 이후만 가져온다. 이 패턴을 <strong>하이 워터마크(High Watermark)</strong> 라고 부른다.</p>
<h2 id="메타데이터-컬럼을-붙인다">메타데이터 컬럼을 붙인다<a hidden class="anchor" aria-hidden="true" href="#메타데이터-컬럼을-붙인다">#</a></h2>
<p>Bronze에 원본 데이터만 넣으면 나중에 답이 안 나오는 질문이 생긴다. &ldquo;이 데이터가 언제 적재된 건가?&rdquo; &ldquo;어느 소스에서 온 건가?&rdquo;</p>
<p>원본 컬럼은 그대로 두고, 메타데이터 컬럼을 추가한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>conn<span style="color:#9ece6a;font-weight:bold">.</span>execute(<span style="color:#9ece6a">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">CREATE OR REPLACE TABLE bronze.orders_with_meta AS
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">SELECT
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">    *,
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">    current_timestamp AS _loaded_at,
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">    &#39;jaffle_shop&#39; AS _source_system,
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">    &#39;full&#39; AS _load_type
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">FROM read_csv_auto(
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">  &#39;https://raw.githubusercontent.com/dbt-labs/jaffle_shop/main/seeds/raw_orders.csv&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">);
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">&#34;&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>conn<span style="color:#9ece6a;font-weight:bold">.</span>execute(<span style="color:#9ece6a">&#34;SELECT * FROM bronze.orders_with_meta LIMIT 3&#34;</span>)<span style="color:#9ece6a;font-weight:bold">.</span>fetchdf()
</span></span></code></pre></div><p><code>_loaded_at</code>, <code>_source_system</code>, <code>_load_type</code>. 언더스코어로 시작하는 이유는 원본 컬럼과 구분하기 위해서다. 원본에 <code>loaded_at</code>이라는 컬럼이 있을 수도 있으니까.</p>
<p>이 메타데이터가 있으면 Silver 변환에서 문제가 생겼을 때 &ldquo;언제 적재한 데이터까지는 정상이고, 이후부터 이상하다&quot;는 식으로 범위를 좁힐 수 있다.</p>
<h2 id="적재-패턴-정리">적재 패턴 정리<a hidden class="anchor" aria-hidden="true" href="#적재-패턴-정리">#</a></h2>
<p>Bronze 적재 패턴을 정리하면 이렇다.</p>
<table>
  <thead>
      <tr>
          <th>패턴</th>
          <th>적용 대상</th>
          <th>구현</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Full Load (덮어쓰기)</td>
          <td>코드 테이블, 소규모 마스터</td>
          <td><code>CREATE OR REPLACE TABLE</code></td>
      </tr>
      <tr>
          <td>Full Load (스냅샷)</td>
          <td>일별 현황 보관이 필요한 경우</td>
          <td>파티션 키로 적재일 사용</td>
      </tr>
      <tr>
          <td>Incremental (타임스탬프)</td>
          <td><code>updated_at</code>이 있는 테이블</td>
          <td><code>WHERE updated_at &gt; 워터마크</code></td>
      </tr>
      <tr>
          <td>Incremental (자동 증가 키)</td>
          <td>로그, 이벤트, 주문</td>
          <td><code>WHERE id &gt; 워터마크</code></td>
      </tr>
      <tr>
          <td>CDC</td>
          <td>삭제 감지가 필요한 경우</td>
          <td>Debezium + Kafka</td>
      </tr>
  </tbody>
</table>
<p>Full Load 중에 <strong>스냅샷</strong> 방식이 하나 더 있다. 덮어쓰기가 아니라 적재일 기준으로 매일의 전체 상태를 따로 저장하는 방식이다. 상품 마스터의 어제 상태와 오늘 상태를 비교하고 싶을 때 쓴다. 스토리지를 많이 먹지만, <a href="https://biz-agentic-ai.github.io/guides/etl-design/001-medallion-architecture/">1편</a>에서 얘기했듯 클라우드 환경에서 스토리지 비용은 무시할 수 있는 수준이다.</p>
<h2 id="실무-참고-airflow로-bronze-적재">실무 참고: Airflow로 Bronze 적재<a hidden class="anchor" aria-hidden="true" href="#실무-참고-airflow로-bronze-적재">#</a></h2>
<p>Bronze 적재를 Airflow DAG으로 짜면 테이블마다 Full Load / Incremental Load를 구분해서 태스크를 나눌 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#c0caf5;background-color:#1a1b26;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#7dcfff">from</span> <span style="color:#e0af68">airflow</span> <span style="color:#7dcfff">import</span> DAG
</span></span><span style="display:flex;"><span><span style="color:#7dcfff">from</span> <span style="color:#e0af68">airflow.operators.python</span> <span style="color:#7dcfff">import</span> PythonOperator
</span></span><span style="display:flex;"><span><span style="color:#7dcfff">from</span> <span style="color:#e0af68">datetime</span> <span style="color:#7dcfff">import</span> datetime
</span></span><span style="display:flex;"><span><span style="color:#7dcfff">import</span> <span style="color:#e0af68">duckdb</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#bb9af7">def</span> <span style="color:#7aa2f7">load_full</span>(table_name, source_url, <span style="color:#9ece6a;font-weight:bold">**</span>context):
</span></span><span style="display:flex;"><span>    <span style="color:#9ece6a">&#34;&#34;&#34;Full Load: 전체 교체&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    conn <span style="color:#9ece6a;font-weight:bold">=</span> duckdb<span style="color:#9ece6a;font-weight:bold">.</span>connect(<span style="color:#9ece6a">&#39;warehouse.duckdb&#39;</span>)
</span></span><span style="display:flex;"><span>    conn<span style="color:#9ece6a;font-weight:bold">.</span>execute(<span style="color:#9d7cd8">f</span><span style="color:#9ece6a">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">        CREATE OR REPLACE TABLE bronze.</span><span style="color:#9ece6a">{</span>table_name<span style="color:#9ece6a">}</span><span style="color:#9ece6a"> AS
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">        SELECT *, current_timestamp AS _loaded_at,
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">               &#39;</span><span style="color:#9ece6a">{</span>table_name<span style="color:#9ece6a">}</span><span style="color:#9ece6a">&#39; AS _source_system, &#39;full&#39; AS _load_type
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">        FROM read_csv_auto(&#39;</span><span style="color:#9ece6a">{</span>source_url<span style="color:#9ece6a">}</span><span style="color:#9ece6a">&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">    &#34;&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>    conn<span style="color:#9ece6a;font-weight:bold">.</span>close()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#bb9af7">def</span> <span style="color:#7aa2f7">load_incremental</span>(table_name, source_url, key_column, <span style="color:#9ece6a;font-weight:bold">**</span>context):
</span></span><span style="display:flex;"><span>    <span style="color:#9ece6a">&#34;&#34;&#34;Incremental Load: 워터마크 이후만&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    conn <span style="color:#9ece6a;font-weight:bold">=</span> duckdb<span style="color:#9ece6a;font-weight:bold">.</span>connect(<span style="color:#9ece6a">&#39;warehouse.duckdb&#39;</span>)
</span></span><span style="display:flex;"><span>    wm <span style="color:#9ece6a;font-weight:bold">=</span> conn<span style="color:#9ece6a;font-weight:bold">.</span>execute(<span style="color:#9d7cd8">f</span><span style="color:#9ece6a">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">        SELECT COALESCE(last_loaded_id, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">        FROM bronze.watermarks WHERE table_name = &#39;</span><span style="color:#9ece6a">{</span>table_name<span style="color:#9ece6a">}</span><span style="color:#9ece6a">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">    &#34;&#34;&#34;</span>)<span style="color:#9ece6a;font-weight:bold">.</span>fetchone()
</span></span><span style="display:flex;"><span>    last_id <span style="color:#9ece6a;font-weight:bold">=</span> wm[<span style="color:#e0af68">0</span>] <span style="color:#bb9af7">if</span> wm <span style="color:#bb9af7">else</span> <span style="color:#e0af68">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    conn<span style="color:#9ece6a;font-weight:bold">.</span>execute(<span style="color:#9d7cd8">f</span><span style="color:#9ece6a">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">        INSERT INTO bronze.</span><span style="color:#9ece6a">{</span>table_name<span style="color:#9ece6a">}</span><span style="color:#9ece6a">
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">        SELECT *, current_timestamp AS _loaded_at
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">        FROM read_csv_auto(&#39;</span><span style="color:#9ece6a">{</span>source_url<span style="color:#9ece6a">}</span><span style="color:#9ece6a">&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">        WHERE </span><span style="color:#9ece6a">{</span>key_column<span style="color:#9ece6a">}</span><span style="color:#9ece6a"> &gt; </span><span style="color:#9ece6a">{</span>last_id<span style="color:#9ece6a">}</span><span style="color:#9ece6a">
</span></span></span><span style="display:flex;"><span><span style="color:#9ece6a">    &#34;&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>    conn<span style="color:#9ece6a;font-weight:bold">.</span>close()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#bb9af7">with</span> DAG(
</span></span><span style="display:flex;"><span>    dag_id<span style="color:#9ece6a;font-weight:bold">=</span><span style="color:#9ece6a">&#39;bronze_ingestion&#39;</span>,
</span></span><span style="display:flex;"><span>    schedule<span style="color:#9ece6a;font-weight:bold">=</span><span style="color:#9ece6a">&#39;0 5 * * *&#39;</span>,
</span></span><span style="display:flex;"><span>    start_date<span style="color:#9ece6a;font-weight:bold">=</span>datetime(<span style="color:#e0af68">2026</span>, <span style="color:#e0af68">1</span>, <span style="color:#e0af68">1</span>),
</span></span><span style="display:flex;"><span>    catchup<span style="color:#9ece6a;font-weight:bold">=</span><span style="color:#e0af68">False</span>,
</span></span><span style="display:flex;"><span>) <span style="color:#bb9af7">as</span> dag:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#414868;font-style:italic"># 소규모 마스터 → Full Load</span>
</span></span><span style="display:flex;"><span>    load_customers <span style="color:#9ece6a;font-weight:bold">=</span> PythonOperator(
</span></span><span style="display:flex;"><span>        task_id<span style="color:#9ece6a;font-weight:bold">=</span><span style="color:#9ece6a">&#39;load_customers_full&#39;</span>,
</span></span><span style="display:flex;"><span>        python_callable<span style="color:#9ece6a;font-weight:bold">=</span>load_full,
</span></span><span style="display:flex;"><span>        op_kwargs<span style="color:#9ece6a;font-weight:bold">=</span>{<span style="color:#9ece6a">&#39;table_name&#39;</span>: <span style="color:#9ece6a">&#39;customers&#39;</span>, <span style="color:#9ece6a">&#39;source_url&#39;</span>: <span style="color:#9ece6a">&#39;...&#39;</span>},
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#414868;font-style:italic"># 대용량 트랜잭션 → Incremental Load</span>
</span></span><span style="display:flex;"><span>    load_orders <span style="color:#9ece6a;font-weight:bold">=</span> PythonOperator(
</span></span><span style="display:flex;"><span>        task_id<span style="color:#9ece6a;font-weight:bold">=</span><span style="color:#9ece6a">&#39;load_orders_incremental&#39;</span>,
</span></span><span style="display:flex;"><span>        python_callable<span style="color:#9ece6a;font-weight:bold">=</span>load_incremental,
</span></span><span style="display:flex;"><span>        op_kwargs<span style="color:#9ece6a;font-weight:bold">=</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#9ece6a">&#39;table_name&#39;</span>: <span style="color:#9ece6a">&#39;orders&#39;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#9ece6a">&#39;source_url&#39;</span>: <span style="color:#9ece6a">&#39;...&#39;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#9ece6a">&#39;key_column&#39;</span>: <span style="color:#9ece6a">&#39;id&#39;</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#414868;font-style:italic"># 병렬 실행 — 테이블 간 의존 관계가 없으니까</span>
</span></span><span style="display:flex;"><span>    [load_customers, load_orders]
</span></span></code></pre></div><p>소규모 마스터는 <code>load_full</code>, 대용량 트랜잭션은 <code>load_incremental</code>. 테이블 특성에 맞게 함수를 나눠서 호출한다. 테이블 간에는 의존 관계가 없으니 Airflow가 병렬로 실행한다.</p>
<p>다음 글에서는 Silver 레이어를 다룬다. Bronze에 쌓아둔 원본 데이터를 정제하고 표준화하는 과정이다. dbt를 본격적으로 쓰기 시작한다.</p>
<div style="margin: 1.2em 0;">
  <a href="https://colab.research.google.com/github/biz-agentic-ai/biz-agentic-ai.github.io/blob/main/notebooks/etl-002-bronze-layer.ipynb" target="_blank" rel="noopener noreferrer"
     style="display: inline-flex; align-items: center; gap: 8px; padding: 10px 20px;
            background: linear-gradient(135deg, #f9ab00 0%, #f57c00 100%);
            color: #fff; text-decoration: none; border-radius: 8px;
            font-weight: 600; font-size: 0.95em;
            box-shadow: 0 2px 8px rgba(245,124,0,0.25);
            transition: all 0.2s ease;">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" fill="white"/>
    </svg>
    Google Colab에서 실습하기
  </a>
</div>



  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://biz-agentic-ai.github.io/tags/etl/">Etl</a></li>
      <li><a href="https://biz-agentic-ai.github.io/tags/bronze/">Bronze</a></li>
      <li><a href="https://biz-agentic-ai.github.io/tags/cdc/">Cdc</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://biz-agentic-ai.github.io/guides/etl-design/001-medallion-architecture/">
    <span class="title">« 이전 페이지</span>
    <br>
    <span>1. 메달리온 아키텍처 - 데이터를 세 겹으로 쌓는 이유</span>
  </a>
  <a class="next" href="https://biz-agentic-ai.github.io/guides/etl-design/003-silver-layer/">
    <span class="title">다음 페이지 »</span>
    <br>
    <span>3. Silver 레이어 - Bronze를 분석 가능한 상태로 올린다</span>
  </a>
</nav>

  </footer>
<div class="comments">
  <script src="https://giscus.app/client.js"
    data-repo="biz-agentic-ai/biz-agentic-ai.github.io"
    data-repo-id="R_kgDOPhm8OQ"
    data-category="General"
    data-category-id="DIC_kwDOPhm8Oc4C2uES"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="preferred_color_scheme"
    data-lang="ko"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
  </script>
</div>

</article>
        </main>
        
<footer class="footer">
        <span>&copy; 2026 <a href="https://biz-agentic-ai.github.io/">Junho Lee | DataNexus 구축 과정</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '복사';

        function copyingDone() {
            copybutton.innerHTML = '복사 완료!';
            setTimeout(() => {
                copybutton.innerHTML = '복사';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</div>
    <script>
    (function() {
        const toggle = document.getElementById('sidebar-toggle');
        const sidebar = document.getElementById('sidebar');
        const overlay = document.getElementById('sidebar-overlay');
        if (toggle && sidebar) {
            toggle.addEventListener('click', function() {
                sidebar.classList.toggle('open');
                overlay.classList.toggle('open');
            });
            overlay.addEventListener('click', function() {
                sidebar.classList.remove('open');
                overlay.classList.remove('open');
            });
        }
    })();
    </script>
</body>

</html>
