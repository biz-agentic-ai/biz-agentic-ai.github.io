---
title: "4. 수퍼-서브 타입 - 고객이 개인이면서 법인일 수 있는가"
date: 2026-02-22
draft: false
summary: "같은 수퍼-서브 타입도 Exclusive인지 Inclusive인지에 따라 의미가 완전히 다르다. 표기법마다 그리는 방식까지 달라서 모델 리뷰에서 해석이 엇갈린다."
categories: ["DW Modeling"]
tags: ["dw-modeling", "erd", "super-sub-type", "generalization"]
series: ["dw-modeling-guide"]
series_order: 4
author: "Junho Lee"
ShowToc: true
---

## "이건 1:1 관계 아닌가요?"

모델 리뷰에서 고객 엔터티 아래에 개인고객, 법인고객이 달려 있는 걸 보고 묻는 사람이 꼭 있다. 관계선만 보면 1:1처럼 보이니까 그렇다.

1:1이 아니다. 수퍼-서브 타입 관계다. 고객이라는 범주(수퍼 타입) 안에서 개인고객과 법인고객이라는 구체적인 분류(서브 타입)로 나뉘는 구조다. 객체지향 프로그래밍의 상속과 개념이 닮았다. 공통 속성(고객명, 연락처)은 수퍼 타입인 고객에 두고, 고유 속성(사업자번호는 법인고객만, 주민번호는 개인고객만)은 서브 타입에 둔다.

왜 이렇게 나누는가. 그냥 "고객"이라고만 하면 범위가 넓다. 개인고객과 법인고객이라고 하면 비즈니스 의미가 또렷해진다. 서브 타입별로 고유한 속성을 따로 관리할 수 있고, 다른 엔터티와 독립적으로 관계를 맺을 수도 있다. 법인고객만 여신한도 엔터티와 관계를 가진다든지 하는 식이다. 고유한 속성이 없다면 서브 타입으로 나눌 실익은 줄어들지만, 의사소통 관점에서는 여전히 쓸모가 있다.

문제는 이 구조가 표기법마다 다르게 그려진다는 점이다. [이전 글]({{< ref "003-erd-notation" >}})에서 관계선과 카디널리티 해석이 표기법마다 다르다는 걸 다뤘는데, 수퍼-서브 타입도 마찬가지다.

## Exclusive와 Inclusive

수퍼-서브 타입에서 가장 먼저 따져야 할 건 서브 타입 간의 관계가 배타적(Exclusive)인지 포함적(Inclusive)인지다.

**Exclusive** 는 수퍼 타입의 인스턴스가 서브 타입 중 정확히 하나에만 속하는 경우다. 고객이 개인고객이면 법인고객이 아니다. 구분코드 하나로 깔끔하게 나뉜다.

**Inclusive** 는 인스턴스가 여러 서브 타입에 동시에 속할 수 있는 경우다. 운송수단을 예로 들어보자. 화물용과 승객용이 서브 타입인데, 화물과 승객을 동시에 싣는 운송수단도 있다. 구분코드가 "화물", "승객", "화물&승객" 세 가지가 필요하다.

```
Exclusive 예시:
[고객] ─┬─ [개인고객]     ← 둘 중 하나에만 속함
        └─ [법인고객]

Inclusive 예시:
[운송수단목적] ─┬─ [화물용]    ← 둘 다에 속할 수 있음
               └─ [승객용]
```

실무에서는 Exclusive가 훨씬 많다. 고객(개인/법인), 계좌(보통/적금/정기), 상품(실물/디지털). 대부분 이 패턴이다. Inclusive는 상대적으로 드문데, 설계 초기에 "이 분류가 정말 배타적인가"를 한 번 더 확인하는 습관이 필요하다. 배타적이라고 가정했다가 나중에 겹치는 케이스가 나오면 모델을 뜯어고쳐야 한다.

## 표기법별 수퍼-서브 타입 표현

### IE(Crow's Foot) 방식

수퍼 타입 아래에 서브 타입들을 별도 엔터티로 그리고, 관계선으로 연결한다. Exclusive와 Inclusive를 구분하는 심볼이 관계선 교차점에 표시된다. 서브 타입 구분자(고객구분코드, 목적유형코드 같은)를 함께 표시해서 어떤 기준으로 나뉘는지를 보여준다.

MicroDesigner 같은 툴에서 IE 표기법을 쓰면 Exclusive와 Inclusive가 시각적으로 뚜렷하게 구분된다. Exclusive는 하나의 심볼로 묶이고, Inclusive는 교차 가능함을 나타내는 다른 형태의 심볼을 쓴다.

### IDEF1X 방식

IE와 비슷하게 서브 타입을 별도 엔터티로 표현하되, 한 가지 개념이 더 있다. **Complete** 와 **Incomplete** 다.

- **Complete** - 서브 타입이 모두 확정된 상태다. 운송수단이 비행기, 철도, 자동차 세 가지뿐이라고 확신하는 경우.
- **Incomplete** - 서브 타입이 아직 다 나오지 않았을 수 있는 상태다. 선박이 추가될 수도 있다고 판단되면 Incomplete로 남겨둔다.

Exclusive/Inclusive와 Complete/Incomplete를 조합하면 네 가지 경우가 나온다. IE에는 없는 개념이라 IDEF1X에서 IE로 표기법을 전환할 때 Complete/Incomplete 정보가 유실된다.

Inclusive 표현에도 차이가 있다. IE에서는 하나의 심볼로 Inclusive를 표현하지만, IDEF1X에서는 서브 타입을 따로 그려서 표현하는 경우가 많다. 같은 구분자를 표시해서 Inclusive라는 걸 알 수는 있지만, 시각적으로 한눈에 들어오지 않는다. 관계선 색깔을 바꾸거나 서브 타입 색을 다르게 처리하는 식의 우회가 필요하다.

### Barker 방식

앞의 두 표기법과 근본적으로 다르다. 서브 타입을 별도 엔터티로 빼지 않고, **수퍼 타입 박스 안에** 서브 타입을 그린다. 시각적으로 포함 관계가 바로 드러나서 직관적이긴 하다.

기본이 Exclusive이고, Inclusive인 경우 구분자에 (Inclusive)를 별도 표시한다. DA# 같은 툴이 이 방식을 기본으로 쓴다.

## 표기법 전환 시 깨지는 것들

프로젝트에서 툴을 바꿀 때 수퍼-서브 타입이 제대로 전환되지 않는 경우가 있다. IE에서 IDEF1X로 넘기면 Complete/Incomplete 정보를 추가로 지정해야 하고, IDEF1X에서 Barker로 넘기면 서브 타입이 수퍼 타입 내부로 들어가면서 레이아웃이 완전히 달라진다.

Inclusive 관계가 특히 문제다. 많은 툴이 IE와 IDEF1X 사이에서 Inclusive의 양방향 자동 전환을 지원하지 못한다. 결국 수동으로 다시 그려야 하는 상황이 생긴다.

[이전 글]({{< ref "003-erd-notation" >}})에서 "프로젝트 시작 시 표기법을 통일하라"고 했는데, 수퍼-서브 타입이야말로 그 이유가 가장 크게 드러나는 부분이다. 관계선 해석이 달라지는 건 그래도 표를 한 장 만들면 정리가 되는데, 수퍼-서브 타입은 구조 자체가 달라져 버린다.

## DW에서의 수퍼-서브 타입

OLTP에서는 수퍼-서브 타입을 논리 모델에서 자유롭게 쓴다. 물리 모델로 갈 때 선택이 갈리는데, 수퍼 타입과 서브 타입을 각각 테이블로 만들 수도 있고 하나의 테이블로 합칠 수도 있다.

DW에서는 상황이 좀 다르다. [2편]({{< ref "002-oltp-vs-dw-model" >}})에서 다뤘던 "접근 경로" 관점이 판단 기준이 된다.

고객 디멘션을 설계한다고 하자. 개인고객과 법인고객을 각각 별도 디멘션으로 만들 건지, 하나의 고객 디멘션에 고객유형 컬럼을 넣어서 통합할 건지. 개인고객과 법인고객의 분석 패턴이 완전히 다르면 나누는 게 낫다. 개인고객 매출은 연령대별로 보고, 법인고객 매출은 산업군별로 보는 식이라면 디멘션 속성 자체가 다르니까. 반대로 고객 전체를 하나의 축으로 놓고 보는 분석이 대부분이면, 통합 디멘션이 편하다.

스타스키마에서 디멘션을 나누면 팩트 테이블에 FK가 늘어나고, 쿼리할 때 어떤 디멘션을 조인할지 판단해야 한다. 통합하면 NULL이 많은 와이드 테이블이 되지만, 클라우드 컬럼나 스토리지에서는 NULL 컬럼의 비용이 거의 없다. [1편]({{< ref "001-cloud-era-dw-modeling" >}})에서 다뤘던 클라우드의 물리적 제약 변화가 이 판단에도 영향을 준다.

다음 글에서는 DW 설계의 두 가지 큰 흐름인 Inmon 방식과 Kimball 방식을 비교한다. 1편에서 간략히 언급했던 내용을 더 구체적으로 들어간다.
